---
path: udontknow-js-1
date: 2020-11-15T06:12:02.930Z
title: 你不知道的JavaScript-读书笔记1
description: 第一章-作用域(scope)是什么
---
最近看了冴羽大神的[JavaScript深入系列](https://github.com/mqyqingfeng/Blog)，收获很多的同时，依然许多地方理解地不够透彻。所以决定沉下心来好好研读一下**你不知道的JavaScript**这个系列，来加深自己对这门语言的理解。这个系列博文只是记录自己在看书的过程中的总结。

---

## 1.1 编译原理
首先第一章说的是作用域(scope)，这个概念熟悉JavasCript的朋友都不会陌生，这里有一段话很好地解释了这个概念。

> 编程语言的一个基本功能是能够储存变量中的值，并且之后可以访问和修改它，这种能力将**状态**这个概念
> 带给了程序，所以我们需要设计一套规则来存储这些变量，这套规则就被称为**作用域**

回到编译原理，一般的程序代码在执行前都会经历三个步骤，这些统称为**编译**
* 分词/词法分析(Tokenizing/Lexing)
<br/>
这里用书中举的例子就能很好说明这个概念，例如`var a = 2;`。这段程序最后会被分解成这样几个词法单元(token)：`var、 a、 =、 2、 ;`。这里在需要注意分词与词法分析之间的差别是对于词法单元的识别是通过**有状态**还是**无状态**的方式进行的。当词法单元生成器在判断a是一个独立词法单元还是其他词法单元的一部分时，则使用的是有状态的解析规则，即为词法分析。
* 解析/语法分析(Parsing)
<br/>
这个过程是将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，即为**抽象语法树**(Abstract Syntax Tree, AST)，很多人应该也听说过。对于上面的例子`var a = 2;`，它的`AST`大概长这样：
```js
VariableDeclaration {
  Identifier: a,
  AssignmentExpression: {
    NumericLiteral: 2
  }
}
```
* 代码生成
<br/>
这个过程是将`AST`转换为可执行代码，也就是生成一组机器指令。

总结来说，就是对于Javascript，一般情况下编译发生在代码执行前几微秒，所以Javascript即使被称作解释性语言，在执行前也是需要编译的，这点和其他大部分编译性语言一样。

## 1.2 理解作用域
回看之前的例子，有三个角色牵扯到对`var a = 2;`的处理过程，分别是：
* 引擎
* 编译器
* 作用域

简单来说，在`var a = 2;`的处理过程中，首先编译器会询问当前作用域是否已经存在一个相同名称的变量a，如果是则会忽略此变量声明，如果不是则会声明一个新变量a，然后在执行`a = 2`的时候引擎则会在作用域中寻找变量a，最后对其进行赋值。

1.2.1 LHS 与 RHS
在引擎对变量进行查询的时候，有两种类型，分别为`LHS`和`RHS`，简单理解就是当变量出现在赋值操作左侧进行`LHS`查询，出现在右侧进行`RHS`查询。可以将`RHS`理解为*retrieve his source value*。举个例子：

对于`console.log(a)`为`RHS`，因为我们尝试去获得变量a的源值

而对于`a = 2`则为`LHS`，因为我们尝试对a进行赋值，需要为赋值操作找到一个目标

这里要注意一点，当调用函数传递具体值给参数时，发生了隐式的`LHS`，即便没有`=`号在这里，比如：
```js
function foo(a) {
    console.log(a) // 2
}
foo(2);
```
在这里对函数`foo`进行了`RHS`引用，同时也有一个隐式的`a = 2`操作，进行了`LHS`查询。

## 1.3 作用域嵌套
这个概念应该都不陌生，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或者达到最外层的作用域(全局)为止。请看下面的例子：
```js
function foo(a) {
    console.log(a + b);
}
var b = 2;
foo(2); // 4
```

## 1.4 异常
对于区分`LHS`与`RHS`是很重要的，在变量还未声明下，两种查询的行为是不一样的。看下面的例子：
```js
function foo(a) {
    console.log(a + b);
    b = a;
}
foo(2);
```
执行上面这段代码，对的`RHS`查询是找不到此变量的。当`RHS`在所有嵌套的作用域中都找不到所需要的变量，引擎则会抛出`ReferenceError`这个异常。

而当引擎执行`LHS`查询时，如果在顶层中也无法找到目标变量，**全局作用域**中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序在非`strict`模式下运行。所以如果对上面例子进行修改：
```js
function foo(a) {
    b = a;
    console.log(a + b);
}
foo(2); // 4
console.log(b); // 2
```
引擎对b进行`LHS`查询，查询不到b，然后在全局中创建了一个全局变量b。但是如果我们对变量b进行了不当的操作，例如将它当作成一个函数类型并执行`b(2)`，则引擎会抛出`TypeError`异常，即便引擎用`RHS`成功找到了变量b。

值得注意的是，如果在严格模式下，上面的例子也会抛出一个`ReferenceError`的异常。

---
第一章大致就这么多，以后或许还有补充，下一章则是**词法作用域**

